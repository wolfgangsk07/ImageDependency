import numpy as npimport pandas as pdfrom openslide import OpenSlidefrom multiprocessing import Pool, Value, Lockfrom skimage.color import rgb2hsvfrom skimage.filters import threshold_otsufrom skimage.io import imsave, imreadfrom skimage.exposure.exposure import is_low_contrastfrom skimage.transform import resizefrom scipy.ndimage import binary_dilation, binary_erosionimport argparseimport loggingimport h5pyfrom tqdm import tqdmimport osimport shutilfrom pathlib import Pathdef get_mask_image(img_RGB, RGB_min=50):    img_HSV = rgb2hsv(img_RGB)    # 向量化处理RGB三通道    backgrounds = [        img_RGB[..., i] > threshold_otsu(img_RGB[..., i])        for i in range(3)    ]    background_R, background_G, background_B = backgrounds  # 解构赋值    # 组织区域逻辑优化版本    tissue_RGB = np.logical_not(background_R & background_G & background_B)    # HSV饱和度通道处理 (保持独立)    tissue_S = img_HSV[..., 1] > threshold_otsu(img_HSV[..., 1])  # S通道索引为1    # 最小值约束的三通道统一处理    min_R, min_G, min_B = [        img_RGB[..., i] > RGB_min        for i in range(3)    ]    mask = tissue_S & tissue_RGB & min_R & min_G & min_B    return maskdef get_mask(slide, level='max', RGB_min=50):    #read svs image at a certain level  and compute the otsu mask    if level == 'max':        level = len(slide.level_dimensions) - 1    # note the shape of img_RGB is the transpose of slide.level_dimensions    img_RGB = np.transpose(np.array(slide.read_region((0, 0),level,slide.level_dimensions[level]).convert('RGB')),                           axes=[1, 0, 2])    tissue_mask = get_mask_image(img_RGB, RGB_min)    return tissue_mask, leveldef extract_patches(slide_path, patch_size,                    patch_path, mask_path, wsi_id, max_patches_per_slide = 50000):    patch_folder = os.path.join(patch_path, wsi_id)    if not os.path.isdir(patch_folder):        os.makedirs(patch_folder)    patch_folder_mask = os.path.join(mask_path, wsi_id)    if not os.path.isdir(patch_folder_mask):        os.makedirs(patch_folder_mask)    if os.path.exists(os.path.join(patch_folder, "complete.txt")):        print(f'{wsi_id}: patches have already been extreacted')        return    path_hdf5 = os.path.join(patch_folder, f"{wsi_id}.hdf5")    hdf = h5py.File(path_hdf5, 'w')    slide = OpenSlide(slide_path)    mask, mask_level = get_mask(slide)    mask = binary_dilation(mask, iterations=3)    mask = binary_erosion(mask, iterations=3)    np.save(os.path.join(patch_folder_mask, "mask.npy"), mask)    mask_level = len(slide.level_dimensions) - 1    PATCH_LEVEL = 0    BACKGROUND_THRESHOLD = .2    ratio_x = slide.level_dimensions[PATCH_LEVEL][0] / slide.level_dimensions[mask_level][0]    ratio_y = slide.level_dimensions[PATCH_LEVEL][1] / slide.level_dimensions[mask_level][1]    xmax, ymax = slide.level_dimensions[PATCH_LEVEL]    # handle slides with 40 magnification at base level    resize_factor = float(slide.properties.get('aperio.AppMag', 20)) / 20.0    if not slide.properties.get('.AppMag', 20): print(f"magnifications for {wsi_id} is not found, using default magnification 20X")    patch_size_resized = (int(resize_factor * patch_size[0]), int(resize_factor * patch_size[1]))    print(f"patch size for {wsi_id}: {patch_size_resized}")    i = 0    indices = [(x, y) for x in range(0, xmax, patch_size_resized[0]) for y in                range(0, ymax, patch_size_resized[0])]    # here, we generate all the pathes with valid mask    if max_patches_per_slide is None:        max_patches_per_slide = len(indices)    np.random.seed(5)    np.random.shuffle(indices)    for x, y in indices:        # check if in background mask        x_mask = int(x / ratio_x)        y_mask = int(y / ratio_y)        if mask[x_mask, y_mask] == 1:            patch = slide.read_region((x, y), PATCH_LEVEL, patch_size_resized).convert('RGB')                   mask_patch = get_mask_image(np.array(patch))            mask_patch = binary_dilation(mask_patch, iterations=3)                        if (mask_patch.sum() > BACKGROUND_THRESHOLD * mask_patch.size) and not (is_low_contrast(patch)):                if resize_factor != 1.0:                    patch = patch.resize(patch_size)                patch = np.array(patch)                tile_name = f"{x}_{y}"                hdf.create_dataset(tile_name, data=patch)                i = i + 1        if i >= max_patches_per_slide:            break    hdf.close()    if i == 0:        print("no patch extracted for slide {}".format(wsi_id))    else:        with open(os.path.join(patch_folder, "complete.txt"), 'w') as f:            f.write('Process complete!\n')            f.write(f"Total n patch = {i}")            print(f"{wsi_id} complete, total n patch = {i}")if __name__ == '__main__':    parser = argparse.ArgumentParser(description='Generate patches from a given folder of images')    parser.add_argument('--patch_size', default=256, type=int, help='patch size, '                                                                    'default 256')    parser.add_argument('--max_patches_per_slide', default=50000, type=int)    parser.add_argument('--svs', required=True,                        help='病理切片，例如：TCGA-GD-A3OP-01Z-00-DX1.A1D66E35-8E4D-4420-AD57-D45016D016D5.svs')    parser.add_argument('--seed', type=int, default=99, help='Seed for random generation')    args = parser.parse_args()    #获取病人ID    wsi_id = args.svs.split('.')[0]     #输出patch地址    patch_path = f"/ramfs/SVS/patches_hdf5/"     #输出mask地址    mask_path = f"/ramfs/SVS/mask_hdf5/"    #database中image文件    wsi_path_old = os.path.join("/mnt/SVS/data/",args.svs)     #内存盘中image文件    wsi_path = os.path.join("/ramfs/",args.svs)    check_file = Path(f"/ramfs/SVS/patches_hdf5/{wsi_id}/complete.txt")    #主体函数部分    if not check_file.exists():        shutil.copy(wsi_path_old, wsi_path)        extract_patches(wsi_path, (args.patch_size, args.patch_size),                patch_path, mask_path, wsi_id, args.max_patches_per_slide)    else:        print(f"您输入的样本{wsi_id}已经完成提取patch")                     #删除拷贝至内存盘的image文件    try:        os.remove(wsi_path)    except FileNotFoundError:        print(f"文件 {wsi_path} 不存在，无需删除")     